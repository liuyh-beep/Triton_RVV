#ifdef C_KERNEL_ENABLE
#include "kernel/softmax.h" // Assumes void softmax(...) is declared here
#endif

#ifdef TRITON_KERNEL_ENABLE
#include "softmax_kernel_launcher.h" // Generated by build_kernel.py
#endif

#include "support/support.h" // Assumes helpers like getDB, readMatrix, check_tensor

#include <vector>
#include <string>
#include <cassert>
#include <chrono>
#include <cstring> // For memset
#include <iostream>
#include <memory>
#include <random>
#include <stdio.h>
#include <stdlib.h>

using namespace std;
using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;

// --- Main Test Harness for Softmax ---
int main(int argc, char *argv[]) {
    // Default parameters (can be overridden by command line)
    int M = 1823; // Number of rows (e.g., BatchSize or BatchSize * SeqLen)
    int N = 781;  // Number of columns (e.g., NumFeatures or NumClasses)
    int RUN_COUNT = 10;

    // --- Argument Parsing ---
    // Override defaults if command line argument "MxNxRUN_COUNT" is provided
    if (argc >= 2) {
        std::vector<int> Shape = splitStringToInts(argv[1]); // Uses 'x' as default delimiter
        if (Shape.size()) {
            assert(Shape.size() == 3 && "Invalid shape format: Provide MxNxRUN_COUNT\n");
            M = Shape.at(0);
            N = Shape.at(1);
            RUN_COUNT = Shape.at(2);
        }
    }
    printf("Softmax Data: M(Rows)=%d, N(Cols)=%d, RUN_COUNT=%d\n", M, N, RUN_COUNT);

    assert(M > 0 && N > 0 && "Invalid shape: M and N must be positive.\n");

    // --- Memory Allocation ---
    size_t elements = (size_t)M * N;
    float *input_ptr = (float *)malloc(elements * sizeof(float));
    float *ref_output_ptr = (float *)malloc(elements * sizeof(float)); // Reference output
    float *real_output_ptr = (float *)malloc(elements * sizeof(float)); // Actual kernel output

    if (!input_ptr || !ref_output_ptr || !real_output_ptr) {
        printf("ERROR: Memory allocation failed!\n");
        free(input_ptr); free(ref_output_ptr); free(real_output_ptr);
        return -1;
    }
    memset(real_output_ptr, 0, elements * sizeof(float));

    // --- Data Initialization ---
#ifdef CHECK_ACCURACY
    printf("Mode: CHECK_ACCURACY. Loading data from text files...\n");
    // File naming convention: DB_FILE_env_prefix_SHAPE_INDEX.txt
    // Input: SHAPE is MxN, index 1
    // Reference Output: SHAPE is MxN, index 2

    std::string shape_str = std::to_string(M) + "x" + std::to_string(N);

    std::string input_file = getDB(shape_str, 1); // getDB from support.h
    // Using readMatrix from support.cpp which expects text files and dimensions header
    int read_m, read_n; // To store dimensions read from file (optional use)
    if (!readMatrix(input_file.c_str(), input_ptr, read_m, read_n) || read_m != M || read_n != N) {
        printf("ERROR: Failed to read or dimension mismatch for input matrix from %s (expected %dx%d, got %dx%d)\n",
               input_file.c_str(), M, N, read_m, read_n);
        // Basic cleanup needed before exit
        free(input_ptr); free(ref_output_ptr); free(real_output_ptr);
        return -1;
    }
    printf("Input (%dx%d) loaded from %s\n", M, N, input_file.c_str());

    std::string ref_output_file = getDB(shape_str, 2);
    if (!readMatrix(ref_output_file.c_str(), ref_output_ptr, read_m, read_n) || read_m != M || read_n != N) {
        printf("ERROR: Failed to read or dimension mismatch for reference output matrix from %s (expected %dx%d, got %dx%d)\n",
               ref_output_file.c_str(), M, N, read_m, read_n);
        // Basic cleanup needed before exit
        free(input_ptr); free(ref_output_ptr); free(real_output_ptr);
        return -1;
    }
    printf("Reference Output (%dx%d) loaded from %s\n", M, N, ref_output_file.c_str());

#else // Not CHECK_ACCURACY
    printf("Mode: Generating random data (CHECK_ACCURACY not defined)...\n");
    std::random_device rd;
    std::mt19937 gen(rd());
    std::normal_distribution<float> norm_dis(0.0f, 1.0f); // For input data

    for (size_t i = 0; i < elements; ++i) {
        input_ptr[i] = norm_dis(gen);
    }
    printf("Random data generated.\n");
#endif // CHECK_ACCURACY

    // --- Kernel Execution and Timing ---

#ifdef C_KERNEL_ENABLE
    printf("Executing C Softmax Kernel %d times...\n", RUN_COUNT);
    auto c_softmax_begin_time = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < RUN_COUNT; i++) {
        softmax(input_ptr, real_output_ptr, M, N); // Call C++ implementation
    }
    auto c_softmax_end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> c_softmax_time_interval = c_softmax_end_time - c_softmax_begin_time;
    PRINT_KERNEL_RUNNING_TIME(C_KERNEL, c_softmax_time_interval.count() / RUN_COUNT)
#endif

#ifdef TRITON_KERNEL_ENABLE
    printf("Executing Triton Softmax Kernel %d times...\n", RUN_COUNT);
    // Grid for softmax: one program per row
    int gridR = M;
    // Strides for Triton kernel (assuming row-major)
    long input_row_stride = N;
    long output_row_stride = N;
    // n_cols is N
    int num_threads_triton = 1; // From your example, could be tuned (e.g., 4)

    auto triton_softmax_begin_time = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < RUN_COUNT; i++) {
        // IMPORTANT: Verify this signature against the generated softmax_kernel_launcher.h
        // Based on softmax_kernel(output_ptr, input_ptr, input_row_stride, output_row_stride, n_cols, BLOCK_SIZE_N)
        // Expected wrap: gridX,Y,Z, num_threads, kernel_ptr,
        //                output_ptr, input_ptr,
        //                input_row_stride (scalar), output_row_stride (scalar), n_cols (scalar)
        softmax_kernel_wrap(
            gridR, 1, 1,               // gridX, gridY, gridZ
            num_threads_triton,        // num_threads
            softmax_kernel,            // kernel_ptr_t
            real_output_ptr,           // arg0 (output_ptr)
            input_ptr,                 // arg1 (input_ptr)
            (int32_t)input_row_stride, // arg2 (scalar)
            (int32_t)output_row_stride,// arg3 (scalar)
            (int32_t)N                 // arg4 (n_cols, scalar)
        );
    }
    auto triton_softmax_end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> triton_softmax_time_interval = triton_softmax_end_time - triton_softmax_begin_time;
    PRINT_KERNEL_RUNNING_TIME(TRITON_KERNEL, triton_softmax_time_interval.count() / RUN_COUNT)
#endif

    // --- Accuracy Check ---
#ifdef CHECK_ACCURACY
    printf("Checking accuracy for Softmax...\n");
    // Using standard check_tensor from support.h
    check_tensor(ref_output_ptr, real_output_ptr, elements, "softmax_output");
    printf("Accuracy check complete.\n");
#endif

    // --- Save Test Data (if it was randomly generated in non-CHECK_ACCURACY mode) ---
    // This part is if you want to save the data used when NOT in CHECK_ACCURACY mode
    // If in CHECK_ACCURACY mode, data was loaded, no need to save it again unless it's the output.
#ifdef KEEP_TEST_DATA
    printf("Mode: KEEP_TEST_DATA. Saving data for Softmax...\n");
    char filename_out[256];
    // Note: The python script saves input_x as _1.txt and ref_out as _2.txt
    // This C++ part under KEEP_TEST_DATA would save what it used/produced.
    std::string current_shape_str = std::to_string(M) + "x" + std::to_string(N);

    snprintf(filename_out, sizeof(filename_out), "matrix_%s_1_computed_input.txt", current_shape_str.c_str());
    writeMatrix(filename_out, input_ptr, M, N);

    snprintf(filename_out, sizeof(filename_out), "matrix_%s_2_computed_output.txt", current_shape_str.c_str());
    writeMatrix(filename_out, real_output_ptr, M, N); // Save the actual output of the kernel
    printf("Computed data saved.\n");
#endif

    // --- Cleanup ---
    printf("Cleaning up Softmax memory...\n");
    free(input_ptr);
    free(ref_output_ptr);
    free(real_output_ptr);
    printf("Cleanup complete. Exiting Softmax main.\n");

    return 0;
}