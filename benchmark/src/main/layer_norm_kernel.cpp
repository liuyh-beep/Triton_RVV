#ifdef C_KERNEL_ENABLE
// Include header for the C++ kernel implementation
#include "kernel/layer_norm.h" // Assumes void layer_norm(...) is declared here
#endif

#ifdef TRITON_KERNEL_ENABLE
// Include header for the Triton kernel launcher (generated by build_kernel.py)
#include "layer_norm_kernel_launcher.h"
#endif

// Include common support functions
#include "support/support.h"

#include <vector>
#include <string>
#include <cassert>
#include <chrono>
#include <cstring> // For memset
#include <iostream>
#include <memory>
#include <random>
#include <stdio.h>
#include <stdlib.h>
#include <cmath>   // For EPSILON comparison if needed, and for reference calc if any

using namespace std;
using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;

const float LN_EPSILON = 1e-5f; // Default epsilon for LayerNorm

// --- Main Test Harness for Layer Normalization ---
int main(int argc, char *argv[]) {
    // Default parameters
    int M = 12;   // Batch Size (or BatchSize * SeqLen)
    int N = 1024;  // Number of Features (e.g., hidden size in Transformer)
    int RUN_COUNT = 10;

    // --- Argument Parsing ---
    // Override defaults if command line argument "MxNxRUN_COUNT" is provided
    if (argc >= 2) {
        std::vector<int> Shape = splitStringToInts(argv[1]); // Helper from support.h
        if (Shape.size()) {
            assert(Shape.size() == 3 && "Invalid shape format: Provide MxNxRUN_COUNT\n");
            M = Shape.at(0);
            N = Shape.at(1);
            RUN_COUNT = Shape.at(2);
        }
    }
    printf("LayerNorm Data: M(Rows)=%d, N(Features)=%d, RUN_COUNT=%d, Epsilon=%.1e\n", M, N, RUN_COUNT, LN_EPSILON);

    // --- Memory Allocation ---
    size_t x_elements = (size_t)M * N;
    size_t weight_elements = (size_t)N; // For gamma and beta

    float *x_ptr = (float *)malloc(x_elements * sizeof(float));
    float *gamma_ptr = (float *)malloc(weight_elements * sizeof(float));
    float *beta_ptr = (float *)malloc(weight_elements * sizeof(float));
    float *ref_output_ptr = (float *)malloc(x_elements * sizeof(float)); // Reference output
    float *real_output_ptr = (float *)malloc(x_elements * sizeof(float)); // Actual kernel output

    if (!x_ptr || !gamma_ptr || !beta_ptr || !ref_output_ptr || !real_output_ptr) {
        printf("ERROR: Memory allocation failed!\n");
        free(x_ptr); free(gamma_ptr); free(beta_ptr); free(ref_output_ptr); free(real_output_ptr);
        return -1;
    }
    memset(real_output_ptr, 0, x_elements * sizeof(float));

    // --- Data Initialization ---
#ifdef CHECK_ACCURACY
    printf("Mode: CHECK_ACCURACY. Loading data from files...\n");
    // File naming convention: matrix_SHAPE_INDEX.txt
    // Input x: SHAPE is MxN, index 1
    // Gamma: SHAPE is N, index 2
    // Beta: SHAPE is N, index 3
    // Reference Output: SHAPE is MxN, index 4

    std::string input_x_file = getDB(std::to_string(M) + "x" + std::to_string(N), 1);
    if (!readMatrix(input_x_file.c_str(), x_ptr, M, N)) { // Assuming readMatrix reads M*N
        printf("ERROR: Failed to read input_x matrix from %s\n", input_x_file.c_str());
        return -1; // Basic cleanup needed before exit
    }
    printf("Input X (%dx%d) loaded from %s\n", M, N, input_x_file.c_str());

    std::string gamma_file = getDB(std::to_string(N), 2);
    // Assuming readLoss can read a 1D float array (N elements)
    if (!readLoss(gamma_file.c_str(), gamma_ptr, N)) {
        printf("ERROR: Failed to read gamma vector from %s\n", gamma_file.c_str());
        return -1;
    }
    printf("Gamma (%d) loaded from %s\n", N, gamma_file.c_str());

    std::string beta_file = getDB(std::to_string(N), 3);
    if (!readLoss(beta_file.c_str(), beta_ptr, N)) {
        printf("ERROR: Failed to read beta vector from %s\n", beta_file.c_str());
        return -1;
    }
    printf("Beta (%d) loaded from %s\n", N, beta_file.c_str());

    std::string ref_output_file = getDB(std::to_string(M) + "x" + std::to_string(N), 4);
    if (!readMatrix(ref_output_file.c_str(), ref_output_ptr, M, N)) {
        printf("ERROR: Failed to read reference output matrix from %s\n", ref_output_file.c_str());
        return -1;
    }
    printf("Reference Output (%dx%d) loaded from %s\n", M, N, ref_output_file.c_str());

#else
    printf("Mode: Generating random data (CHECK_ACCURACY not defined)...\n");
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<> ur_dist(-1.0f, 1.0f); // For x, gamma, beta

    for (size_t i = 0; i < x_elements; ++i) x_ptr[i] = ur_dist(gen);
    for (size_t i = 0; i < weight_elements; ++i) {
        gamma_ptr[i] = ur_dist(gen) * 0.5f + 0.8f; // Values around 1
        beta_ptr[i]  = ur_dist(gen) * 0.2f;       // Values around 0
    }
    printf("Random data generated.\n");
#endif

    // --- Kernel Execution and Timing ---

    #ifdef TRITON_KERNEL_ENABLE
    printf("Executing Triton LayerNorm Kernel %d times...\n", RUN_COUNT);
    int gridM = M; // One program per row/sample
    long stride_x_m = N;
    // Strides not needed by wrapper based on error message: stride_x_n, stride_gamma_n, stride_beta_n, stride_output_n
    long stride_output_m = N; // Stride needed according to header signature for arg10
    int num_threads_triton = 4; // Example, or from config

    high_resolution_clock::time_point beginTimeT = high_resolution_clock::now();
    for (int i = 0; i < RUN_COUNT; i++) {
        // --- BEGIN REPLACEMENT ---
        // Call the wrapper function with exactly 14 arguments matching the declaration
        layer_norm_kernel_wrap(
            gridM,                 // 1: gridX
            1,                     // 2: gridY
            1,                     // 3: gridZ
            num_threads_triton,    // 4: num_threads
            layer_norm_kernel,     // 5: kernel_ptr
            x_ptr,                 // 6: arg0 (x_ptr)
            gamma_ptr,             // 7: arg1 (gamma_ptr)
            beta_ptr,              // 8: arg2 (beta_ptr)
            real_output_ptr,       // 9: arg3 (output_ptr)
            (int32_t)M,            // 10: arg4 (M)
            (int32_t)N,            // 11: arg5 (N)
            (int32_t)stride_x_m,   // 12: arg6 (stride_x_m)
          // Removed arguments corresponding to missing args 7, 8, 9, 11
            (int32_t)stride_output_m,// 13: arg10 (stride_output_m)
            LN_EPSILON             // 14: arg12 (epsilon)
        );
        // --- END REPLACEMENT ---
    }
    high_resolution_clock::time_point endTimeT = high_resolution_clock::now();
    std::chrono::duration<double> triton_duration = endTimeT - beginTimeT;
    PRINT_KERNEL_RUNNING_TIME(TRITON_KERNEL, triton_duration.count() / RUN_COUNT)
#endif

#ifdef C_KERNEL_ENABLE
    printf("Executing C LayerNorm Kernel %d times...\n", RUN_COUNT);
    high_resolution_clock::time_point beginTimeC = high_resolution_clock::now();
    for (int i = 0; i < RUN_COUNT; i++) {
        layer_norm(x_ptr, gamma_ptr, beta_ptr, real_output_ptr, M, N, LN_EPSILON);
    }
    high_resolution_clock::time_point endTimeC = high_resolution_clock::now();
    std::chrono::duration<double> c_duration = endTimeC - beginTimeC;
    PRINT_KERNEL_RUNNING_TIME(C_KERNEL, c_duration.count() / RUN_COUNT)
#endif

    // --- Accuracy Check ---
#ifdef CHECK_ACCURACY
    printf("Checking accuracy for LayerNorm...\n");
    check_tensor(ref_output_ptr, real_output_ptr, x_elements, "layer_norm_output");
    printf("Accuracy check complete.\n");
#endif

    // --- Save Test Data ---
#ifdef KEEP_TEST_DATA
    printf("Mode: KEEP_TEST_DATA. Saving computed data for LayerNorm...\n");
    char filename[256];
    // Example filenames (consistent with how python script might save them for CHECK_ACCURACY)
    snprintf(filename, sizeof(filename), "matrix_%dx%d_1_computed.txt", M, N); // input x
    writeMatrix(filename, x_ptr, M, N);
    snprintf(filename, sizeof(filename), "matrix_%d_2_computed.txt", N); // gamma
    writeLoss(filename, gamma_ptr, N); // Using writeLoss for 1D float array
    snprintf(filename, sizeof(filename), "matrix_%d_3_computed.txt", N); // beta
    writeLoss(filename, beta_ptr, N);
    snprintf(filename, sizeof(filename), "matrix_%dx%d_4_computed.txt", M, N); // output
    writeMatrix(filename, real_output_ptr, M, N);
    printf("Computed data saved.\n");
#endif

    // --- Cleanup ---
    printf("Cleaning up LayerNorm memory...\n");
    free(x_ptr); free(gamma_ptr); free(beta_ptr);
    free(ref_output_ptr); free(real_output_ptr);
    printf("Cleanup complete. Exiting LayerNorm main.\n");

    return 0;
}