#ifdef C_KERNEL_ENABLE
// Include header for the C++ kernel implementation
// Assumes convention: kernel/<kernel_name>.h containing the function declaration
#include "kernel/cross_entropy.h" // Needs to declare: void cross_entropy(float*, long*, float*, int, int);
#endif

#ifdef TRITON_KERNEL_ENABLE
// Include header for the Triton kernel launcher (generated by build_kernel.py)
#include "cross_entropy_kernel_launcher.h" // Needs to declare: cross_entropy_kernel_wrap(...) and cross_entropy_kernel (function ptr type)
#endif

// Include common support functions (timing, I/O, checking, etc.)
#include "support/support.h"

#include <vector>
#include <string>
#include <cassert>
#include <chrono>
#include <cstring> // For memset
#include <iostream>
#include <memory>
#include <random>
#include <stdio.h>
#include <stdlib.h>
#include <cmath> // For ceil in Triton grid calculation (if needed)

using namespace std;
using std::chrono::high_resolution_clock;
using std::chrono::milliseconds;

// --- Main Test Harness for Cross Entropy ---
int main(int argc, char *argv[]) {
  // Default parameters
  int M = 128; // Batch Size
  int N = 1000; // Number of Classes
  int RUN_COUNT = 10; // Number of times to run the kernel for timing

  // --- Argument Parsing ---
  // Override defaults if command line argument "MxNxRUN_COUNT" is provided
  if (argc >= 2) {
    std::vector<int> Shape = splitStringToInts(argv[1]); // Helper from support.h
    if (Shape.size()) {
      // Cross entropy shape: M (batch), N (classes)
      assert(Shape.size() == 3 && "Invalid shape format: Provide MxNxRUN_COUNT\n");
      M = Shape.at(0);
      N = Shape.at(1);
      RUN_COUNT = Shape.at(2);
    }
  }
  printf("Data shape M(BatchSize)=%d, N(Classes)=%d, RUN_COUNT=%d\n", M, N, RUN_COUNT);

  // --- Memory Allocation ---
  size_t logits_elements = (size_t)M * N;
  size_t labels_elements = (size_t)M;
  size_t loss_elements = (size_t)M; // Output loss is per batch item

  float *logits_ptr = (float *)malloc(logits_elements * sizeof(float));
  long *labels_ptr = (long *)malloc(labels_elements * sizeof(long)); // Labels are class indices
  float *ref_loss_ptr = (float *)malloc(loss_elements * sizeof(float)); // Reference output for accuracy check
  float *real_loss_ptr = (float *)malloc(loss_elements * sizeof(float)); // Actual output from the kernel

  // Basic check for allocation success
  if (!logits_ptr || !labels_ptr || !ref_loss_ptr || !real_loss_ptr) {
      printf("ERROR: Memory allocation failed!\n");
      // Clean up any partially allocated memory
      free(logits_ptr); free(labels_ptr); free(ref_loss_ptr); free(real_loss_ptr);
      return -1;
  }

  // Initialize the kernel's output buffer (optional, but good practice)
  memset(real_loss_ptr, 0, loss_elements * sizeof(float));

  // --- Data Initialization ---
#ifdef CHECK_ACCURACY
  // Load input data and reference output from files if checking accuracy
  printf("Mode: CHECK_ACCURACY. Loading data from files...\n");
  // Assuming getDB and I/O functions in support.h are adapted for logits (MxN float), labels (M long), loss (M float)
  std::string logits_file = getDB(std::to_string(M) + "x" + std::to_string(N), 1); // Type 1: logits
  // Use readMatrix for 2D float logits
  if (!readMatrix(logits_file.c_str(), logits_ptr, M, N)) {
    printf("ERROR: Failed to read input logits matrix from %s\n", logits_file.c_str());
    // Perform cleanup before returning
    free(logits_ptr); free(labels_ptr); free(ref_loss_ptr); free(real_loss_ptr);
    return -1;
  }
  printf("Logits (%dx%d) loaded from %s\n", M, N, logits_file.c_str());

  std::string labels_file = getDB(std::to_string(M), 2); // Type 2: labels
  // ASSUMPTION: readLabels function exists in support library for reading 'long' type labels
  if (!readLabels(labels_file.c_str(), labels_ptr, M)) {
    printf("ERROR: Failed to read input labels vector from %s\n", labels_file.c_str());
     // Perform cleanup before returning
    free(logits_ptr); free(labels_ptr); free(ref_loss_ptr); free(real_loss_ptr);
    return -1;
  }
  printf("Labels (%d) loaded from %s\n", M, labels_file.c_str());

  std::string loss_file = getDB(std::to_string(M), 3); // Type 3: reference loss
  // ASSUMPTION: readLoss function exists in support library for reading 1D float loss
  if (!readLoss(loss_file.c_str(), ref_loss_ptr, M)) {
    printf("ERROR: Failed to read reference loss vector from %s\n", loss_file.c_str());
     // Perform cleanup before returning
    free(logits_ptr); free(labels_ptr); free(ref_loss_ptr); free(real_loss_ptr);
    return -1;
  }
  printf("Reference Loss (%d) loaded from %s\n", M, loss_file.c_str());

#else
  // Generate random data if not checking accuracy
  printf("Mode: Generating random data (CHECK_ACCURACY not defined)...\n");
  std::random_device rd;
  std::mt19937 gen(rd());
  std::normal_distribution<> norm_dist(0.0, 1.0);       // Normal distribution for logits
  std::uniform_int_distribution<> label_dist(0, N - 1); // Uniform distribution for labels [0, N-1]

  for (size_t i = 0; i < logits_elements; ++i) {
    logits_ptr[i] = static_cast<float>(norm_dist(gen));
  }
  for (size_t i = 0; i < labels_elements; ++i) {
    labels_ptr[i] = static_cast<long>(label_dist(gen));
  }
  printf("Random data generated.\n");
#endif // CHECK_ACCURACY

  // --- Kernel Execution and Timing ---

// Inside ./benchmark/src/main/cross_entropy_kernel.cpp

#ifdef TRITON_KERNEL_ENABLE
  printf("Executing Triton Kernel %d times...\n", RUN_COUNT);
  // Grid dimension for cross entropy kernel is M (one program per sample)
  int gridX = M;
  int gridY = 1;
  int gridZ = 1;
  // Match argument name in header if desired, or keep numWarps
  int num_threads = 4; // Or use numWarps if you prefer that variable name

  // Calculate only the strides potentially needed by the wrapper
  long stride_logits_m = N; // Stride between rows for logits - often the most important
  // The other strides (stride_logits_n, stride_labels, stride_loss) are likely not needed by the wrapper

  // Timing loop
  high_resolution_clock::time_point beginTime = high_resolution_clock::now();
  for (int i = 0; i < RUN_COUNT; i++) {
    // Call the wrapper function with exactly 11 arguments matching the declaration
    cross_entropy_kernel_wrap(
        gridX,              // Arg 1: uint32_t gridX
        gridY,              // Arg 2: uint32_t gridY
        gridZ,              // Arg 3: uint32_t gridZ
        num_threads,        // Arg 4: int num_threads (or numWarps)
        cross_entropy_kernel, // Arg 5: kernel function pointer type
        logits_ptr,         // Arg 6: void* arg0
        labels_ptr,         // Arg 7: void* arg1
        real_loss_ptr,      // Arg 8: void* arg2
        (int32_t)M,         // Arg 9: int32_t arg3 (Cast M)
        (int32_t)N,         // Arg 10: int32_t arg4 (Cast N)
        (int32_t)stride_logits_m // Arg 11: int32_t arg5 (Pass only one stride, cast)
        // Do NOT pass stride_logits_n, stride_labels, stride_loss here
    );
  }
  high_resolution_clock::time_point endTime = high_resolution_clock::now();
  std::chrono::duration<double> triton_duration = endTime - beginTime;
  // Use helper macro from support.h to print time in standard format
  PRINT_KERNEL_RUNNING_TIME(TRITON_KERNEL, triton_duration.count() / RUN_COUNT)
#endif // TRITON_KERNEL_ENABLE

#ifdef C_KERNEL_ENABLE
  printf("Executing C Kernel %d times...\n", RUN_COUNT);
  // Timing loop
  high_resolution_clock::time_point beginTime = high_resolution_clock::now();
  for (int i = 0; i < RUN_COUNT; i++) {
    // Call the C++ kernel implementation directly
    cross_entropy(logits_ptr, labels_ptr, real_loss_ptr, M, N);
  }
  high_resolution_clock::time_point endTime = high_resolution_clock::now();
  std::chrono::duration<double> c_duration = endTime - beginTime;
  // Use helper macro from support.h to print time in standard format
  PRINT_KERNEL_RUNNING_TIME(C_KERNEL, c_duration.count() / RUN_COUNT)
#endif // C_KERNEL_ENABLE

  // --- Accuracy Check ---
#ifdef CHECK_ACCURACY
  printf("Checking accuracy...\n");
  // Use check_tensor helper from support.h
  // Ensure it handles potential floating point inaccuracies appropriately and works for 1D float arrays.
  check_tensor(ref_loss_ptr, real_loss_ptr, loss_elements, "loss_output");
  printf("Accuracy check complete.\n");
#endif // CHECK_ACCURACY


  // --- Save Test Data ---
#ifdef KEEP_TEST_DATA
  printf("Mode: KEEP_TEST_DATA. Saving computed data...\n");
  char filename[256];
  bool success = true;

  // Save logits (use writeMatrix for 2D float)
  snprintf(filename, sizeof(filename), "logits_%dx%d_input.txt", M, N);
  if (!writeMatrix(filename, logits_ptr, M, N)) { // From support.h
      printf("Warning: Failed to save input logits to %s\n", filename);
      success = false;
  }
  // Save labels (ASSUMPTION: writeLabels exists for 1D long)
  snprintf(filename, sizeof(filename), "labels_%d_input.txt", M);
  if (!writeLabels(filename, labels_ptr, M)) { // Assumed helper from support.h
      printf("Warning: Failed to save input labels to %s\n", filename);
      success = false;
  }
  // Save computed loss (ASSUMPTION: writeLoss exists for 1D float)
  snprintf(filename, sizeof(filename), "loss_%d_computed.txt", M);
  if (!writeLoss(filename, real_loss_ptr, M)) { // Assumed helper from support.h
      printf("Warning: Failed to save computed loss to %s\n", filename);
      success = false;
  }

  if(success) {
     printf("Computed data saved.\n");
  } else {
     printf("Warning: Some data files may not have been saved.\n");
  }
#endif // KEEP_TEST_DATA

  // --- Cleanup ---
  printf("Cleaning up memory...\n");
  free(logits_ptr);
  free(labels_ptr);
  free(ref_loss_ptr);
  free(real_loss_ptr);
  printf("Cleanup complete. Exiting.\n");

  return 0;
}